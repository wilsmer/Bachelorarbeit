\section{Abschätzung des Rechenaufwands}\label{sec:abschaetzung_Rechenaufwand}

\subsection{Gegenüberstellung von reellen und komplexen Eingangswerten}
Die Sensormatrix liefert für jedes Sensorelement einen Sinus- und einen Kosinuswert. Diese können für die Berechnung der DFT zu einer komplexen Zahl zusammengefasst werden. 
Auf diese Weise lässt sich die Berechnung mathematisch kompakter schreiben.

\begin{table}[htbp]
\centering
\caption{Takte für die komplexe DFT}
\begin{tabular}{ccccc}
\hline
\multirow{2}{*}{Zeile} & Additionen & Takte pro Element & Takte für & Summe der\\
      & pro Element ($N$) & ($\log_2(N)$) & Multiplikation & Takte\\
\hline
 1& 8  & 3   &0 &3\\
 2& 12 & 3,6 &1 &5\\
 3& 8  & 3   &0 &3\\
 4& 12 & 3,6 &1 &5\\
 5& 8  & 3   &0 &3\\
 6& 12 & 3,6 &1 &5\\
 7& 8  & 3   &0 &3\\
 8& 12 & 3,6 &1 &5\\
\hline
\end{tabular}
\end{table}

(3+5)$\cdot$4$\cdot$8=256 Takte sowohl für den Real- als auch den Imaginärteil der komplexen Ausgangsmatrix. Real- und Imaginärteil werden parallel berechnet.

Wenn nun aber die Eingangswerte in Real- und Imaginärteil getrennt werden, entfallen die Hälfte der Multiplikationen. Dass der Faktor für den Real- als auch den Imaginärteil 
mindestens betragsmäßig $\frac{\sqrt{2}}{2}$ ist, könnte im komplexen Fall wiederum ausgenutzt werden.
Dadurch, dass die Eingangswerte rein reell sind, kommen beispielsweise keine $j^2$-Kompnenten zustande, welche auf die reellen Elemente aufaddiert werden müssten.
Aus diesem Grund müssen weniger Werte aufsummiert werden. Wie das Ausummieren erfolgt, kann in Abschnitt (\ref{sec:Berechnungsschema}) nachgelesen werden.

\begin{table}[htbp]
\centering
\caption{Takte für die reelle DFT am Beispiel der reellen Ausgangsmatrix}
\begin{tabular}{ccccc}
\hline
\multirow{2}{*}{Zeile} & Additionen & Takte pro Element & Takte für & Summe der\\
      & pro Element ($N$) & ($\log_2(N)$) & Multiplikation & Takte\\
\hline
 1& 8 & 3   &0 &3\\
 2& 6 & 2,6 &1 &4\\
 3& 4 & 2   &0 &2\\
 4& 6 & 2,6 &1 &4\\
 5& 8 & 3   &0 &3\\
 6& 6 & 2,6 &1 &4\\
 7& 4 & 2   &0 &2\\
 8& 6 & 2,6 &1 &4\\
\hline
\end{tabular}
\end{table}

Da es nur ganze Takte gibt, errechnen sich für den speziellen Fall der Twiddlefaktormatrix für die 8x8-DFT so (3+4+2+4+3+4+2+4)$\cdot$8=208 Takte. Der Imaginärteil errechnet 
sich noch schneller, da die 1. und 5. Zeile keinen Beitrag leisten. So ergeben sich dort (0+3+2+3+0+3+2+3)$\cdot$8=128 Takte. Da beides parallel berechnet wird, kann hieraus
kein Nutzen gezogen werden.


Wie in Abschnitt \ref{sec:Konstantenmultiplizierer} gezeigt wird, kann die Multiplikation
mit einer Konstanten innerhalb eines Taktes mit einem Schaltnetz erfolgen. Für die Negation sollte ebenfalls ein Takt eingeplant werden, weshalb der zeitliche Gewinn vermutlich
begrenzt ist.


Interessant ist dieser Ansatz dann, wenn die Recheneinheit so klein wie irgend möglich gehalten werden soll. Zu bedenken gilt es dann, dass zusätzlicher Speicher für 
Zwischenwerte vorhanden sein muss. Da der Platzbedarf hierfür nicht zu unterschätzen ist, relativiert sich die Ersparnis in gewissem Umfang. Auf eine Gegenüberstellung
wird an dieser Stelle verzichtet.


Wenn das Signal der Sensoren als von einander unabhängige Sinus- und Kosinuswerte  und somit als rein reell aufgefasst wird, reduziert sich der Aufwand wie 
bei dieser Betrachtung wie in Gl. (\ref{eq:halb_komplexe_Multiplikation}) zu sehen auf zwei Multiplikationen und eine Addition. 

\begin{align}\label{eq:halb_komplexe_Multiplikation}
\begin{split}
 e + jf &= a \cdot (c + jd)\\
        &= a \cdot c + j(a \cdot d)\\
\end{split}
\end{align}

Es ist somit auch an dieser Stelle noch einmal gezeigt worden, dass keine imaginären Anteile des Eingangssignals in die Berechnung mit einfließen.
Das ließe sich ausnutzen, um durch explizit einprogrammierte Multiplikationen den Aufwand deutlich zu verringern. Wie in Abschnitt (\ref{sec:rein_reelle_dft})
%sowie Grafik (\ref{pic:reelleDFT}) 
erläutert wurde, können zudem noch weitere Multiplikationen durch symmetrische Spiegelung der Hälfte der Werte eingespart werden.

 
\subsection{Direkte Multiplikation zweier 8x8 Matrizen}
Die in Abschnitt (\ref{sec:Matrixmultiplikation}) erläuterte Matrixmultiplikation bedarf bei einer 8x8 Matrix je Ergebnis der Ausgangsmatrix 8 Multiplikationen. Für
die 8$\cdot$8=64 Elemente werden deshalb 512 Multiplikationen benötigt. Da es sich sowohl bei den Eingangswerten als auch bei der Twiddlefaktormatrix um komplexe
Zahlen handelt, sind, wie in Abschnitt (\ref{sec:komplexe_Multiplikation}) beschrieben, insgesamt 512$\cdot$4=2048 Multiplikationen nötig.

Sollte sich dazu entschieden werden die Sinus- und Kosinusanteile separat zu berechnen, um ein rein reelles Eingangssignal weiter zu verarbeiten, sind, wie in Abschnitt
(\ref{sec:rein_reelle_dft}) hergeleitet, knapp die Hälfte der Multiplikationen unnötig. In Abbildung (\ref{pic:reelleMatMultRedundanz}) ist zu sehen, dass von den 64 
Ergebniswerten nur 40 berechnet werden müssen. Da die Eingangswerte zwar rein reell, die Twiddlefaktormatrix aber komplex ist, verdoppelt sich die Anzahl der Multiplikationen.
Somit müssen für die gesamten 64 Werte 40$\cdot$8$\cdot$2=640 Multiplikationen durchgeführt werden.

Im komplexen Fall verdoppelt sich für die 2D-DFT schlicht die Anzahl der reellen Multiplikationen und liegt somit bei 4096. Im reellen Fall müssen, wie in Abbildung 
(\ref{pic:reelleDFT}) gezeigt, der Real- sowie der Imaginärteil separat mit der Twiddlefaktormatrix multipliziert werden. So ergeben sich alles in allem 
640$\cdot$3$\cdot$2=3840 reelle Multiplikationen. Diese Zahl liegt nur nur geringfügig unterhalb der komplexen Berechnung.



Hierbei wird von einer Twiddlefaktormatrix mit 64 komplexen Werten ausgegangen. In Wirklichkeit sind es nur 16, die übrigen erfordern überhaupt keine Multiplikation, da 
entweder der Real- oder der Imaginärteil 0 ist. Da dies aber Bestandteil der optimierten Matrixmultiplikation ist, wird an dieser Stelle nicht weiter darauf eingegangen.
Später werden nur die komplexen Varianten verglichen. Dies wird als ausreichend erachtet, da aufgrund der hier und in Abschnitt (\ref{sec:rein_reelle_dft}) angedeutete deutlich 
erhöhte Bedarf an Takten die reelle Matrixmultiplikation nicht von Interesse ist. 


\subsection{Optimierte Multiplikation zweier 8x8 Matrizen}\label{sec:OptimierteMatrixmultiplikation}

Aus der anfänglichen Implementation bei der alle Werte einer Berechnung die entweder mit $+\frac{\sqrt{2}}{2}$ oder $-\frac{\sqrt{2}}{2}$ multipliziert werden müssen 
einzelnd berechnet werden, wird sinngemäß der gemeinsame Faktor ausgeklammert, sodass nur noch jeweils eine Multiplikation erforderlich ist.

Da die erste Zeile der Twiddlefaktormatrix nur aus Einsen im Real- und Nullen im Imaginärteil besteht, kann und muss hier nichts optimiert werden. 
Bei den weiteren Zeilen sind hingegen die Zahlen zur Hälfte positiv und zur anderen negativ. Außerdem enthalten die geraden Zeilen den Faktor $\pm\frac{\sqrt{2}}{2}$. 
Dies lässt sich ausnutzen, um die Anzahl der der Multiplikationen zu reduzieren. Zunächst können die 

Für jede gerade Zeile der DFT ist jeweils für den Real- und den Imaginärteil eine Multiplikation nötig, so dass sich insgesamt acht Multiplikationen ergeben



\subsection{Gegenüberstellung von Butterfly und optimierter Matrixmultiplikation} 

Die \gls{dft} wurde als Matrixmultiplikation implementiert, um die gewonnenen Erkenntnisse auch auf andere Dimensionen als $2^n$, insbesondere ungerade, 
übertragen zu können.  
Zu einem frühen Zeitpunkt der Überlegungen für diese Arbeit gab es noch die Idee die \gls{dft} so flexibel wie möglich zu halten, um unkompliziert auf andere Größen wechseln zu können.
Hierfür sollten alle Koeffizienten der Twiddlefaktormatrix ladbar sowie die Größe der Matrix über eine globale Deklaration definierbar sein.
Diese Herangehensweise bedingt die Implementation als Matrixmultiplikation. Die Hoffnung der Projektgruppe bestand darin, dass das Synthesewerkzeug den 
VHDL-Code soweit optimiert, dass dies nicht händisch erfolgen müsste.
Als klar war, dass die Optimierung nicht so tief greift, wurden die entsprechenden Schritte manuell umgesetzt. 
  
Die Implementierung des Butterfly-Algorithmus nach Cooley und Tukey wurde bereits in Grafik (\ref{pic:Butterfly}) gezeigt. Sie stellt eine effiziente Berechnung der \gls{dft} dar, in 
Abschnitt (\ref{sec:OptimierteMatrixmultiplikation}) konnte gezeigt werden, dass sich beide nur unwesentlich im Rechenaufwand unterscheiden.


\section{Kompromiss aus benötigter Chipfläche und Genauigkeit des Ergebnisses}
Durch die Begrenzung der Bitbreite ist es nötig nach jeder Addition den Wert zu halbieren. Hierbei steigt die Abweichung gegenüber einer verlustfreien Berechnung immer dann, 
wenn das letzte eine 1 ist. Im Mittel ist dies bei der Hälfte der Additionen der Fall. In 50$\%$ aller Fälle wird also der Wert um ein halbes LSB zu viel verringert.
Bei der Multiplikation verdoppelt sich sogar die resultierende Bitbreite. Da mit dem vollständigen 13 Bit Vektor nach der Addition weitergerechnet wird, muss die Konstante
ebenfalls in 13 Bit hinterlegt sein. Deshalb hat das Ergebnis 26 Bit, von denen für die weitere Berechnung wieder nur 12 übernommen werden. In den Abbildungen 
(\ref{pic:AkkumulationUngeradeSpalten}) und (\ref{pic:AkkumulationGeradeSpalten}) wird das hier beschriebene Vorgehen veranschaulicht. Bei diesem Verfahren
kommt es unweigerlich zur Akkumulation von Fehlern.
 
Da für die Berechnung einer Zahl der 1D-DFFT je nach Zeile entweder 8 oder 12 Werte akkumuliert sowie 0 bis 4 Werte multipliziert werden und für die 2D-DFT entsprechend doppelt 
so viele, akkumulieren sich zwangsläufig Fehler. Bei 12 Bit Eingangswerten wäre ein 47? Bit Ausgangsvektor nötig, um dies vollständig zu vermeiden. Dies ist jedoch aus u.a.
Platzgründen nicht umsetzbar.
$\Rightarrow$ Anhand eines Simulationsbeispiels zeigen, dass die mit VHDL berechneten Werte immer kleiner als die in Matlab berechneten sind.
