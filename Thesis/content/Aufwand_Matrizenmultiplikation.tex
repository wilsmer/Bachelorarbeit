\section{Abschätzung des Rechenaufwandes}\label{sec:abschaetzung_Rechenaufwand}

\subsection{Gegenüberstellung reelle / komplexe Eingangswerte}
Die Sensormatrix liefert für jedes Sensorelement einen Sinus- und einen Kosinuswert. Diese können für die Berechnung der DFT zu einer komplexen Zahl zusammengefasst werden. 
Auf diese Weise lässt sich die Berechnung mathematisch kompakter schreiben. Dadurch, dass eine komplexe Multiplikation, wie in Gleichung (\ref{eq:komplexe_Multiplikation}) 
gezeigt wurde, auf vier reellen Multiplikationen basiert,
ist es jedoch so, dass die Anzahl reeller Multiplikationen hierdurch derer bei der getrennten Berechnung und anschließenden Zusammenführung übersteigt.

Beweisen!



Wenn das Signal der Sensoren als von einander unabhängige Sinus- und Kosinuswerte  und somit als rein reell aufgefasst wird, reduziert sich der Aufwand wie 
bei dieser Betrachtung wie in Gl. (\ref{eq:halb_komplexe_Multiplikation}) zu sehen auf zwei Multiplikationen und eine Addition. 

\begin{align}\label{eq:halb_komplexe_Multiplikation}
\begin{split}
 e + jf &= a \cdot (c + jd)\\
        &= a \cdot c + j(a \cdot d)\\
\end{split}
\end{align}

Es ist somit auch an dieser Stelle noch einmal gezeigt worden, dass keine imaginären Anteile des Eingangssignals in die Berechnung mit einfließen.
Das ließe sich ausnutzen, um durch expliziet einprogrammierte Multiplikationen den Aufwand deutlich zu verringern. Wie in Abschnitt (\ref{sec:rein_reelle_dft})
%sowie Grafik (\ref{pic:reelleDFT}) 
erläutert wurde, können zudem noch weitere Multiplikationen durch symmetrische Spiegelung der Hälfte der Werte eingespart werden.

\subsection{2D-DFT als Matrixmultiplikation}
Die \gls{dft} kann als Summation oder als Matrixmultiplikation geschrieben werden, wobei sich letzteres auf einem \gls{asic} bedeutend besser implementieren lässt. 
 

\subsection{Gegenüberstellung Butterfly / Matrixmultiplikation} 
  Die \gls{dft} wurde als Matrixmultiplikation implementiert, nachfolgend soll dies begründet und ein Vergleich beider Varianten erfolgen.
  
  Zu einem frühen Zeitpunkt der Überlegungen 
  an dieser Arbeit gab es noch die Idee die \gls{dft} so flexibel wie möglich zu halten, um unkompliziert auf andere Größen wechseln zu können.
  Hierfür sollten alle Koeffizienten der Twiddlefaktormatrix ladbar sein sowie die Größe der Matrix über eine globale Deklaration variabel gehalten werden.
  Diese Herangehensweise bedingt die Implementation als Matrixmultiplikation. Die Hoffnung der Projektgruppe bestand darin, dass das Synthesewerkzeug den 
  VHDL-Code soweit optimiert, dass dies nicht händisch erfolgen müsste.
  Als klar war, dass sie Optimierung nicht so tief greift, wurden die entsprechenden Schritte manuell umgesetzt. 
  
  Die Implementierung des Butterfly-Algorithmus nach Cooley und Tukey stellt eine effiziente Berechnung der \gls{dft} dar. 
  
  
 \subsection{Anzahl der benötigten Multiplikationen}
 \subsection{Optimierte Matrixmultiplipation bezogen auf 8x8}