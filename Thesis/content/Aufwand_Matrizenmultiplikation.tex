\section{Abschätzung des Rechenaufwandes}\label{sec:abschaetzung_Rechenaufwand}

\subsection{Matrizenmultiplikation}

Die \gls{dft} kann als Summation oder als Matrixmultiplikation geschrieben werden, wobei sich letzteres auf einem \gls{asic} bedeutend besser implementieren lässt. 
Gleichung \ref{eq:dft_matrixmultiplication} stellt die \gls{dft} als Matrizenmultiplikation dar, wobei $x(t)$ der Eingangsvektor (bzw. -matrix) im Zeitbereich und $W$ 
die Twiddlefaktormatrix ist.

\begin{align}\label{eq:dft_matrixmultiplication}
 X = W \cdot x \cdot W = X^* \cdot W
\end{align}

% 
% Betrachtet wird zunächst die Multiplikation eines Vektors mit einer Matrix. 
% 
% \begingroup
% \renewcommand*{\arraystretch}{1.0}
% 
%  \[
%   \stackrel{\mbox{$X^*$}}{
%   \begin{bmatrix}%
%    \myBlackBox \\
%    \myLightgrayBox \\
%    \myLightgrayBox \\
%    \myLightgrayBox
%   \end{bmatrix}
%   }
%   =
%   \stackrel{\mbox{$W$}}{
%    \begin{bmatrix}
%     \myBlackBox 	& \myBlackBox 		& \myBlackBox 		& \myBlackBox \\
%     \myLightgrayBox 	& \myLightgrayBox 	& \myLightgrayBox 	& \myLightgrayBox \\
%     \myLightgrayBox 	& \myLightgrayBox 	& \myLightgrayBox 	& \myLightgrayBox \\
%     \myLightgrayBox 	& \myLightgrayBox 	& \myLightgrayBox 	& \myLightgrayBox
%    \end{bmatrix}
%   }
%   \cdot
%   \stackrel{\mbox{$x$}}{
%    \begin{bmatrix}
%     \myBlackBox \\
%     \myBlackBox \\
%     \myBlackBox \\
%     \myBlackBox
%    \end{bmatrix}
%   }
%  \]
% \endgroup
% 
%  \vspace{1cm}  
  
 \[
  \stackrel{\mbox{$X^*$}}{
   \begin{bmatrix}
    \myBlackBox 	& \myBlackBox 		& \myBlackBox 		& \myBlackBox \\
    \myDarkgrayBox 	& \myDarkgrayBox 	& \myDarkgrayBox 	& \myDarkgrayBox \\
    \myGrayBox 		& \myGrayBox 		& \myGrayBox 		& \myGrayBox \\
    \myLightgrayBox 	& \myLightgrayBox 	& \myLightgrayBox 	& \myLightgrayBox 
   \end{bmatrix}
  }
  =
  \stackrel{\mbox{$W$}}{
   \begin{bmatrix}
    \myBlackBox 	& \myBlackBox 		& \myBlackBox 		& \myBlackBox \\
    \myDarkgrayBox 	& \myDarkgrayBox 	& \myDarkgrayBox 	& \myDarkgrayBox \\
    \myGrayBox 		& \myGrayBox 		& \myGrayBox 		& \myGrayBox \\
    \myLightgrayBox 	& \myLightgrayBox 	& \myLightgrayBox 	& \myLightgrayBox 
   \end{bmatrix}
  }
  \cdot
  \stackrel{\mbox{$x$}}{
   \begin{bmatrix}
    \myBlackBox & \myBlackBox & \myBlackBox & \myBlackBox \\
    \myBlackBox & \myBlackBox & \myBlackBox & \myBlackBox \\
    \myBlackBox & \myBlackBox & \myBlackBox & \myBlackBox \\
    \myBlackBox & \myBlackBox & \myBlackBox & \myBlackBox 
   \end{bmatrix}
  }
 \]

 
 \[
  \stackrel{\mbox{$X$}}{
   \begin{bmatrix}
    \myBlackBox 	& \myBlackBox 		& \myBlackBox 		& \myBlackBox \\
    \myDarkgrayBox 	& \myDarkgrayBox 	& \myDarkgrayBox 	& \myDarkgrayBox \\
    \myGrayBox 		& \myGrayBox 		& \myGrayBox 		& \myGrayBox \\
    \myLightgrayBox 	& \myLightgrayBox 	& \myLightgrayBox 	& \myLightgrayBox 
   \end{bmatrix}
  }
  =
  \stackrel{\mbox{$X^*$}}{
   \begin{bmatrix}
    \myBlackBox 	& \myBlackBox 		& \myBlackBox 		& \myBlackBox \\
    \myDarkgrayBox 	& \myDarkgrayBox 	& \myDarkgrayBox 	& \myDarkgrayBox \\
    \myGrayBox 		& \myGrayBox 		& \myGrayBox 		& \myGrayBox \\
    \myLightgrayBox 	& \myLightgrayBox 	& \myLightgrayBox 	& \myLightgrayBox 
   \end{bmatrix}
  }
  \cdot
  \stackrel{\mbox{$W$}}{
   \begin{bmatrix}
    \myBlackBox & \myBlackBox & \myBlackBox & \myBlackBox \\
    \myBlackBox & \myBlackBox & \myBlackBox & \myBlackBox \\
    \myBlackBox & \myBlackBox & \myBlackBox & \myBlackBox \\
    \myBlackBox & \myBlackBox & \myBlackBox & \myBlackBox 
   \end{bmatrix}
  }
 \]
 

  \subsection{Gegenüberstellung Butterfly / Matrixmultiplipation} 
  Die \gls{dft} wurde als Matrixmultiplikation implementiert, nachfolgend soll dies begründet und ein Vergleich beider Varianten erfolgen.
  
  Zu einem frühen Zeitpunkt der Überlegungen 
  an dieser Arbeit gab es noch die Idee die \gls{dft} so flexibel wie möglich zu halten, um unkompliziert auf andere Größen wechseln zu können.
  Hierfür sollten alle Koeffizienten der Twiddlefaktormatrix ladbar sein sowie die Größe der Matrix über eine globale Deklaration variabel gehalten werden.
  Diese Herangehensweise bedingt die Implementation als Matrixmultiplikation. Die Hoffnung der Projektgruppe bestand darin, dass das Synthesewerkzeug den 
  VHDL-Code soweit optimiert, dass dies nicht händisch erfolgen müsste.
  Als klar war, dass sie Optimierung nicht so tief greift, wurden die entsprechenden Schritte manuell umgesetzt. 
  
  Die Implementierung des Butterfly-Algorithmus nach Cooley und Tukey stellt eine effiziente Berechnung der \gls{dft} dar. 
  
  
  \subsection{Gegenüberstellung reelle / komplexe Eingangswerte}
  Die Sensormatrix liefert für jeden Pixel einen Sinus- und Kosinuswert. Diese können für die Berechnung der DFT zu einer komplexen Zahl zusammengefasst werden. 
  Auf diese Weise lässt sich die Berechnung mathematisch kompakter schreiben. Dadurch, dass eine komplexe Multiplikation auf vier reellen Multiplikationen basiert,
  ist es jedoch möglich, dass die Anzahl reeller Multiplikationen hierdurch derer bei der getrennten Berechnung und anschließenden Zusammenführung übersteigt.
  
  Bei der Berechnung der DFT 
 
  
 \subsection{Anzahl der benötigten Multiplikationen}
 \subsection{Optimierte Matrixmultiplipation bezogen auf 8x8}