\section{Entwicklungsstufen}
\subsection{Multiplikation}

Zeigen, welche Bits heraus genommen werden müssen! und belegen warum.

\subsection{Addierer}
CLA, RC, in einem Takt

\subsection{Konstantenmultiplikation}

\subsection{1D-DFT mit Integer-Werten}
 
\subsection{2D-DFT mit Integer-Werten}

\subsection{2D-DFT mit Werten SQ-Format}

\subsection{Vertauschen der Twiddlefaktor-Matrix-Zeilen ergibt IDFT}

\section{Test der Matrizenmultiplikation}
Zunächst wurde die Berechnung als Ganzzahl-Multiplikation mit dem Faktor 3 betrachtet. Da es bei diesem Faktor und den gewählten Eingangswerten nicht zu einem 
Überlauf kommen kann, war es zu diesem Zeitpunkt noch nicht nötig, sich Gedanken über die Breite des Ergebnisvektors bzw den Ausschnitt daraus für die weitere
Berechnung zu machen. Auch konnte an dieser Stelle noch auf den Bitshift zur Halbierung der Werte verzichtet werden.

Erst als der Faktor $\frac{\sqrt{2}}{2}$ übernommen wurde, wurden die Ergebnisse breiter als der Vektor für die weitere Berechnung an Bits zur Verfügung stellt.
Daraus folgt, dass ein Teil der Bits abgeschnitten werden müssen. Da die Dualzahlen jetzt im S1Q10-Format betrachtet werden, es sich also um Kommazahlen handelt,
müssen die hinteren Bits abgeschnitten werden. Zudem können vorne Bits ohne Informationsverlust gestrichen werden, da durch die Multiplikation ein weiteres 
Negations-Bit dazugekommen ist und auf Grund des gegebenen Faktors der Wertebereich vorne nie ganz ausgenutzt wird. (Verifizieren / Belegen!)


\section{Implementierung des Konstantenmultiplizieres}\label{sec:Konstantenmultiplizierer}

Anfangs wurde angenommen, dass Multiplikationen mit den Twiddlefaktoren $\pm 1$ und $\pm\frac{\sqrt{2}}{2}$ durchgeführt werden müssen. 
Dass bei einer optimierten 8x8-DFT wegen des explizieten ausprogrammierens der Berechnungen die Multiplikation mit $\pm1$ wegfällt, wurde recht schnell klar.
Erst bei genauer Betrachtung der Twiddlefaktor-Matrix viel auf, dass in jeder Zeile gleich viele Additionen wie Subtraktionen vorhanden sind. Durch Umsortieren 
ist es dadurch möglich auf das Invertieren der Eingangswerte sowie den hierfür benötigten Takt und die Inverter zu verzichten. Weiter wird auch nur die Multiplikation
mit $+\frac{\sqrt{2}}{2}$ benötigt.

\subsection{Syntheseergebnis eines 13 Bit Kostantenmultiplizierers}
\begin{figure}[!ht]
\centering  
 %\fbox{
  \includegraphics[width=1\textwidth]{img/13Bit_Konstantenmultiplizierer_Netlist.png}
  %}
  \caption{13 Bit Konstantenmultiplizierer für $\frac{\sqrt{2}}{2} = 0,70711... \simeq 0,70703 = 0001011010100_2$ in Encounter; Eingang links, Ausgang rechts}
\end{figure}



\begin{table}[!ht]
 \caption{Vergleich Konstanten- mit regulärem Multiplizierer}
 \label{tab:VergleichMultiplizierer}
 \begin{tabular}{ccc}
 \hline
				& Konstantenmultiplizierer 	& regulärer Multiplizierer\\
  \hline	
  Gatter			& 27				& 175 \\
  Fläche (Prozess: 350nm)	& $\SI{6612}{\mu m^2}$		& $\SI{23261}{}$\\
  \hline
 \end{tabular}
\end{table}


Der Ausgang hat so wie der Eingang 13 Bit.

Auf Skript verweisen, mit dem ermittelt wurde, dass das die beste Annäherung an $\frac{\sqrt{2}}{2}$ ist.

Der vollständige Gate-Report befindet sich in Abschnitt \ref{src:rc_gate_report} auf Seite \pageref{src:rc_gate_report}



\subsection{Syntheseergebnis für die Bildung des Zweierkomplements eines 13 Bit Vektors}

Zum Vergleich soll hier die nicht Implementierte aber in Abschnitt (\ref{sec:GegenüberstellungRelleKomplexeEingangswerte}) erwähnte Negierung von Zahlen gezeigt werden.

\begin{figure}[htpb]
\centering
\includegraphics[width=0.99\textwidth]{img/13Bit_Inverter_Netlist.png}
\caption{Netzliste einer Einheit zur Bildung des 2er-Komplements eines 13 Bit Vektors; Eingang links, Ausgang rechts}
\label{pic:13BitInverter}
\end{figure}

Für die Negierung eines 13 Bit Vektors mit 22 Standardzellen sind knapp doppelt so viele Gatter nötig wie der Vektor Bits breit ist. Wie zu in Abb. (\ref{pic:13BitInverter})
sehen handelt es sich fast ausschließlich um Inverter und Addierer. In Abschnitt (\ref{sec:Integer2erKomplement}) wurde bereits beschrieben, dass für die Bildung des
2er-Komplements zunächst alle Bits invertiert werden müssen. Abschließend wird auf den Vektor 1 LSB addiert.
