
\input{preamble.tex}
\begin{document}

 \input{content/Deckblatt_Rueckseite.tex}
 \input{content/abstract.tex}
 
 \pagenumbering{Roman} 
 \tableofcontents
 
 %\paragraph{}
 
 %\setcounter{page}{1}
 
 
 \input{content/Einleitung.tex}
 
 \pagenumbering{arabic} 
 
 \chapter{Grundlagen}
 Um einen guten Ausgangspunkt für spätere Erläuterungen zu haben, sollen an dieser Stelle die wesentlichen Grundlagen zusammengefasst werden.
 \input{content/Zahlendarstellung.tex}
 \section{Mathematische Grundlagen}
 Zu den mathematischen Grundlagen werden die komplexe Multiplikation sowie die Matrixmultiplikation gezählt, welche nachfolgen kurz behandelt werden.
 Auf die Fouriereihenentwicklung sowie insbesondere die Fouriertransformation und ihre diskrete Variante wird im Anschluss detaillierter eingegangen, da
 sie elementarer Bestandteil dieser Arbeit sind.
 Da auch die diskrete Kosinustransformation als mögliche Transformationsart im Raum stand, um in den Bildbereich zu gelangen, wird diese ebenfalls kurz aufgegriffen.
 \input{content/Komplexe_Multiplikation.tex}
 \input{content/Matrixmultiplikation.tex}
 \input{content/Fouriertransformation.tex}
 \input{content/Berechnung_DFT.tex} 
 \input{content/Berechnung_FFT.tex}
 \input{content/Berechnung_IDFT.tex}
 \input{content/Berechnung_DCT.tex} 
 
 
 
 
 
 
\chapter{Analyse}
Im diesem Kapitel werden zunächst die \gls{dft} und die \gls{dct} in verschiedenen Größen einander gegenüber gestellt und eine Entscheidung darüber getroffen, welche
sich besser dafür eignet auf einem \gls{asic} implementiert zu werden. Hierbei spielen in erster Linie die Anzahl unterschiedlicher Faktoren eine Rolle, 
da für identische Faktoren nur eine Multiplikationseinheit nötig ist. Gleiche Faktoren gehen also mit einer kleineren Chipfläche einher, was zusammen mit der schnellen 
Berechnung, also geringe Zahl benötigter Takte, die beiden Hauptziele bei der Chipimplementierung darstellen.
Als interessante Kandidaten wurden primär die Matrizen mit den Größen 8x8, 9x9 und 15x15 ausgewählt. 
Die 8x8-Matrix hat dieselbe Anzahl der Sensoren wie das derzeitige Demo-Array, so dass die Eingangswerte
direkt transformiert werden können. 
Die beiden anderen haben aufgrund ihrer ungeraden Zahl ihren Mittelpunkt zwischen den mittleren Sensorelementen, was für die 
weitere Verarbeitung des transformierten Signals von Bedeutung ist. Die Matrix der Dimension 15x15 lässt sich durch Interpolation der Daten errechnen, während es für
die 9x9 bisher keine Überlegungen gibt, wie sie errechnet werden könnte.
Die 12x12 sowie die 16x16 werden zum besseren Einordnen der Bewertungen ebenfalls betrachtet.
Darüber hinaus ist aus Abschnitt \ref{sec:BerechnungFFT} bekannt, dass die \gls{fft} auf 2$^n$ Elementen basiert und es sich hierbei um ein sehr schnelles und 
effizientes Verfahren handelt. 

Im zweiten Schritt wird untersucht, wie die 8x8-\gls{dft}, welche als Favorit aus der ersten Betrachtung herausgegangen ist, optimiert werden kann.


 \input{content/Bewertung_DCT.tex}
 \input{content/Bewertung_DFT.tex}
 %\input{content/DCT_DFT.tex}
 
 \input{content/Aufwand_Matrizenmultiplikation.tex}

 
 
 
\chapter{Entwurf}

 

 
 
 
 
 \input{content/Implementierung_Konstantenmultiplizierer.tex} 
 
 
 
 \section{Kompromiss aus benötigter Chipfläche und Genauigkeit des Ergebnisses}
Dieser Abschnitt passt hier nicht so richtig hin! Aber wo sonst?

Durch die Begrenzung der Bitbreite ist es nötig nach jeder Addition den Wert zu halbieren. Hierbei steigt die Abweichung gegenüber einer verlustfreien Berechnung immer dann, 
wenn das letzte eine 1 ist. Im Mittel ist dies bei der Hälfte der Additionen der Fall. In 50$\%$ aller Fälle wird also der Wert um ein halbes LSB zu viel verringert.
Bei der Multiplikation verdoppelt sich sogar die resultierende Bitbreite. Da mit dem vollständigen 13 Bit Vektor nach der Addition weitergerechnet wird, muss die Konstante
ebenfalls in 13 Bit hinterlegt sein. Deshalb hat das Ergebnis 26 Bit, von denen für die weitere Berechnung wieder nur 12 übernommen werden. In den Abbildungen 
\ref{pic:AkkumulationUngeradeSpalten} und \ref{pic:AkkumulationGeradeSpalten} wird das hier beschriebene Vorgehen veranschaulicht. Bei diesem Verfahren
kommt es unweigerlich zur Akkumulation von Fehlern.
 
Da für die Berechnung einer Zahl der 1D-DFT je nach Zeile entweder 8 oder 12 Werte akkumuliert sowie 0 bis 4 Werte multipliziert werden und für die 2D-DFT entsprechend doppelt 
so viele, akkumulieren sich zwangsläufig Fehler. Bei 12 Bit Eingangswerten wäre ein 47? Bit Ausgangsvektor nötig, um dies vollständig zu vermeiden. Dies ist jedoch aus u.a.
Platzgründen nicht umsetzbar.

Mit jeder Addition kommt 1\,Bit dazu. So werden aus 12\,Bit bis zur Multiplikation 15 (12 + $\log_2(8)$), 8 = Anzahl der Zahlen die mit $\tfrac{\sqrt{2}}{2}$ multipliziert
werden müssen. Bei der Multiplikation verdopplet sich der Wert, also 30 und eine letzte Addition macht 31.
Beim zweiten Durchlauf werden es so (31+3)$\cdot$2+1=69\,Bit.

$\Rightarrow$ Anhand eines Simulationsbeispiels zeigen, dass die mit VHDL berechneten Werte immer kleiner als die in Matlab berechneten sind.


\input{content/Implementierung_DFT.tex}



  
 \chapter{Evaluation}
 \input{content/Simulation.tex}


 \section{Testumgebung}
 \subsection{Struktogramm des Testablaufs}
 \subsection{Reale Eingangswerte}
 
 \section{Chipdesign}
 \subsection{Anzahl Standardzellen}
 \subsubsection{Benötigte Standardzellen für 1D / 2D}
 \subsubsection{Benötigte Standardzellen bei 3 Lagen / 4 Lagen}
 \subsection{Visualisierung der Netzliste}
 \subsection{Floorplan, Padring}
 
 \chapter{Schlussfolgerungen}
 \section{Zusammenfassung}
 \section{Bewertung und Fazit}
 Es konnte eine effiziente Berechnung implementiert werden, die der FFT in nichts nachsteht. Wenn nicht die Ausgangssituation gewesen wäre, dass eine möglichst flexibel gehaltene
 Matrixmultiplikation erstrebenswert ist, hätte auch eine FFT, dessen Berechnungsvorschrift bekannt ist, implementiert werden können. Für DFT anderer Größe als $2^N$ gilt dies nicht.
 
 
 \section{Ausblick}
 
 
 \printglossary[title={Abkürzungsverzeichnis}] 
 
 \listoffigures
 \addcontentsline{toc}{chapter}{\listfigurename}

 \listoftables
 \addcontentsline{toc}{chapter}{\listtablename}

 
 \printbibliography
 \addcontentsline{toc}{chapter}{Literatur}
 
 \chapter{Anhang}
 \input{content/Anhang.tex}

\end{document}
